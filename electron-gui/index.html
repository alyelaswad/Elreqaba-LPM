<!DOCTYPE html>
<html data-theme="light">
<head>
    <title>Process Monitor</title>
    <style>
        :root {
            /* Light theme */
            --bg-primary: #ffffff;
            --bg-secondary: #f8fafc;
            --bg-tertiary: #f1f5f9;
            --text-primary: #0f172a;
            --text-secondary: #475569;
            --accent-color: #3b82f6;
            --accent-hover: #2563eb;
            --border-color: #e2e8f0;
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        [data-theme="dark"] {
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --bg-tertiary: #334155;
            --text-primary: #f8fafc;
            --text-secondary: #94a3b8;
            --border-color: #334155;
            --chart-bg: #1e293b;
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.3);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.3), 0 2px 4px -2px rgb(0 0 0 / 0.3);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3), 0 4px 6px -4px rgb(0 0 0 / 0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            transition: background-color 0.3s, color 0.3s, border-color 0.3s, box-shadow 0.3s;
            will-change: auto;
        }

        body {
            background-color: var(--bg-secondary);
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            color: var(--text-primary);
            line-height: 1.5;
        }

        .container {
            padding: 24px;
            max-width: 1200px;
            margin: 0 auto;
            opacity: 0;
            transform: translateY(20px);
            animation: fadeIn 0.5s ease-out forwards;
        }

        @keyframes fadeIn {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
            background-color: var(--bg-primary);
            padding: 20px 24px;
            border-radius: 16px;
            box-shadow: var(--shadow-md);
        }

        .title {
            font-size: 24px;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .title::before {
            content: "‚ö°";
            font-size: 28px;
        }

        .controls {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .theme-toggle {
            background: none;
            border: none;
            cursor: pointer;
            padding: 8px;
            border-radius: 8px;
            font-size: 20px;
            color: var(--text-secondary);
            transition: all 0.2s;
        }

        .theme-toggle:hover {
            background-color: var(--bg-tertiary);
            transform: scale(1.1);
        }

        .tabs {
            display: flex;
            gap: 2px;
            background-color: var(--bg-primary);
            padding: 8px;
            border-radius: 12px;
            box-shadow: var(--shadow-sm);
            margin-bottom: 24px;
        }

        .tab {
            padding: 12px 24px;
            cursor: pointer;
            border-radius: 8px;
            color: var(--text-secondary);
            font-weight: 500;
            transition: all 0.2s;
            flex: 1;
            text-align: center;
        }

        .tab:hover {
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .tab.active {
            background-color: var(--accent-color);
            color: white;
        }

        .tab-content {
            display: none;
            background-color: var(--bg-secondary);
            border-radius: 16px;
            box-shadow: var(--shadow-md);
            opacity: 0;
            transform: translateY(10px);
            transition: all 0.3s ease-out;
        }

        .tab-content.active {
            display: block;
            opacity: 1;
            transform: translateY(0);
        }

        .process-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            background-color: var(--bg-primary);
            border-radius: 16px;
            overflow: visible;
            position: relative;
        }

        .process-table th {
            background-color: var(--bg-tertiary);
            padding: 16px;
            text-align: left;
            font-weight: 600;
            color: var(--text-primary);
            border-bottom: 2px solid var(--border-color);
        }

        .process-table td {
            padding: 16px;
            border-bottom: 1px solid var(--border-color);
            color: var(--text-secondary);
        }

        .process-row {
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .process-row:hover {
            background-color: var(--bg-tertiary);
        }

        .process-row td {
            position: relative;
        }

        .process-row.selected {
            background-color: var(--accent-color);
            color: white;
        }

        .process-row.selected td {
            color: white;
        }

        .action-menu {
            position: fixed;
            background-color: var(--bg-primary);
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            display: none;
            z-index: 1000;
            min-width: 200px;
            padding: 8px;
            border: 1px solid var(--border-color);
        }

        .action-menu.visible {
            display: block;
        }

        .action-item {
            padding: 12px 16px;
            cursor: pointer;
            transition: all 0.2s;
            border-radius: 8px;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }

        .action-item::before {
            font-size: 16px;
        }

        .action-item[data-action="kill"]::before {
            content: "‚ö°";
        }

        .action-item[data-action="pause"]::before {
            content: "‚è∏Ô∏è";
        }

        .action-item[data-action="resume"]::before {
            content: "‚ñ∂Ô∏è";
        }

        .action-item[data-action="priority"]::before {
            content: "‚öôÔ∏è";
        }

        .action-item:hover {
            background-color: var(--bg-tertiary);
            color: var(--accent-color);
        }

        .button {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .button-primary {
            background-color: var(--accent-color);
            color: white;
        }

        .button-primary:hover {
            background-color: var(--accent-hover);
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }

        .button-secondary {
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .button-secondary:hover {
            background-color: var(--border-color);
            transform: translateY(-1px);
        }

        .graphs-container {
            padding: 24px;
            color: var(--text-secondary);
            background-color: var(--bg-secondary);
            border-radius: 16px;
        }

        .chart-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 24px;
            margin-bottom: 24px;
        }

        .chart-container {
            padding: 24px;
            background-color: var(--bg-primary);
            border-radius: 16px;
            box-shadow: var(--shadow-md);
            transition: transform 0.2s, box-shadow 0.2s;
            height: 300px;
            border: 1px solid var(--border-color);
        }

        .chart-container.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .chart-container:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }

        .track-container {
            background-color: var(--bg-primary);
            color: var(--text-primary);
        }

        .track-container input[type="number"] {
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .track-container .chart-row {
            background-color: var(--bg-primary);
        }

        .track-container .chart-container {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
        }

        .track-container .grouped-processes {
            background-color: var(--bg-secondary);
        }

        .tracked-processes, .grouped-processes {
            margin-top: 24px;
            display: grid;
            gap: 16px;
        }

        .process-card {
            padding: 10px;
            background-color: var(--bg-secondary);
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 10px;
            border: 1px solid var(--border-color);
        }

        .group-card {
            margin-bottom: 15px;
            background-color: var(--bg-primary);
            padding: 20px;
            border-radius: 8px;
            box-shadow: var(--shadow-md);
            border: 1px solid var(--border-color);
        }

        .group-card-content {
            font-size: 0.9em;
            color: var(--text-secondary);
        }

        .group-card-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: var(--text-primary);
        }

        input[type="number"] {
            padding: 12px 16px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            font-size: 14px;
            transition: all 0.2s;
            width: 200px;
        }

        input[type="number"]:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .remove-button {
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .remove-button:hover {
            background-color: #ef4444;
            color: white;
        }

        /* Loading animation */
        @keyframes pulse {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }

        .loading {
            animation: pulse 1.5s infinite;
        }

        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
                scroll-behavior: auto !important;
            }
        }

        .memory-efficient {
            content-visibility: auto;
            contain: content;
        }

        .dropdown-menu {
            position: fixed;
            background: var(--bg-primary);
            border: none;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            padding: 8px 0;
            min-width: 160px;
            backdrop-filter: blur(10px);
            border: 1px solid var(--border-color);
            display: none;
        }

        .dropdown-item {
            padding: 10px 16px;
            cursor: pointer;
            color: var(--text-primary);
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s ease;
            position: relative;
            border-bottom: 1px solid var(--border-color);
        }

        .dropdown-item:last-child {
            border-bottom: none;
        }

        .dropdown-item:hover {
            background-color: var(--bg-tertiary);
        }

        [data-theme="dark"] .dropdown-menu {
            background: var(--bg-primary);
            border-color: var(--border-color);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
        }

        [data-theme="dark"] .dropdown-item {
            color: var(--text-primary);
            border-color: var(--border-color);
        }

        [data-theme="dark"] .dropdown-item:hover {
            background-color: var(--bg-tertiary);
        }

        .actions-cell {
            text-align: center;
            position: relative;
            z-index: 1;
        }

        .dropdown-container {
            position: relative;
            display: inline-block;
            z-index: 1;
        }

        .action-button {
            background: none;
            border: none;
            cursor: pointer;
            padding: 8px;
            color: var(--text-secondary);
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 18px;
            position: relative;
            z-index: 1;
        }

        .action-button:hover {
            color: var(--accent-color);
            background-color: var(--bg-tertiary);
        }

        /* Add a subtle divider between dropdown items */
        .dropdown-item:not(:last-child) {
            border-bottom: 1px solid var(--border-color);
        }

        /* Add a subtle animation when showing the dropdown */
        @keyframes dropdownAppear {
            from {
                opacity: 0;
                transform: scale(0.95);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .dropdown-menu.show {
            display: block;
            animation: dropdownAppear 0.2s ease;
        }

        /* Ensure the dropdown is above everything when visible */
        .dropdown-menu[style*="display: block"] {
            z-index: 1000;
        }

        /* Add styles for chart containers */
        .chart-container {
            background-color: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 20px;
            margin: 10px;
        }

        .graphs-container {
            background-color: var(--bg-primary);
            padding: 24px;
            border-radius: 16px;
        }

        [data-theme="dark"] .chart-container {
            background-color: var(--bg-primary);
        }

        [data-theme="dark"] .graphs-container {
            background-color: var(--bg-primary);
        }

        [data-theme="dark"] .chart-row {
            background-color: var(--bg-primary);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="title">ÿßŸÑÿ±ŸÇÿßÿ®ÿ© ÿßŸÑÿπÿßŸÖÿ© ÿ™ÿ≠ÿ™ ÿ•ÿ¥ÿ±ÿßŸÅ ÿßŸÑŸÉŸàŸÖÿßŸÜÿØŸàÿ± ÿπŸÖÿ±Ÿà ÿßŸÑŸÇÿßÿ∂Ÿâ ÿßŸÑŸÖŸäÿÆŸàÿ± ÿØŸäŸÑ ŸÖŸàŸÜÿØŸà</div>
            <div class="controls">
                <button class="theme-toggle" id="themeToggle">üåô</button>
                <button class="button button-secondary" id="pauseUpdate">
                    <span class="icon">‚è∏Ô∏è</span>
                    <span>Pause Update</span>
                </button>
                <button class="button button-primary" id="refresh">
                    <span class="icon">üîÑ</span>
                    <span>Refresh</span>
                </button>
            </div>
        </div>
        
        <div class="tabs">
            <div class="tab active" data-tab="processes">Process Table</div>
            <div class="tab" data-tab="graphs">Graphs</div>
            <div class="tab" data-tab="track">Track Process</div>
        </div>

        <div class="tab-content active" id="processes">
            <table class="process-table">
                <thead>
                    <tr>
                        <th>PID</th>
                        <th>Name</th>
                        <th>CPU %</th>
                        <th>Memory</th>
                        <th>State</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody id="processList">
                    <!-- Process rows will be inserted here -->
                </tbody>
            </table>
        </div>

        <div class="tab-content" id="graphs">
            <div class="graphs-container">
                <div class="chart-row">
                    <div class="chart-container">
                        <h2>Memory Usage History</h2>
                        <canvas id="memoryChart"></canvas>
                    </div>
                    <div class="chart-container">
                        <h2>CPU Utilization</h2>
                        <canvas id="cpuChart"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <div class="tab-content" id="track">
            <div class="track-container">
                <div style="margin-bottom: 20px;">
                    <input type="number" id="trackPid" placeholder="Enter PID to track">
                    <button class="button button-primary" id="addTrack">Track Process</button>
                    <label style="margin-left: 15px; color: var(--text-primary);">
                        <input type="checkbox" id="groupProcesses">
                        Group processes by name
                    </label>
                </div>
                <div class="tracked-processes">
                    <h3 style="color: var(--text-primary);">Tracked Processes</h3>
                    <div id="trackedList"></div>
                </div>
                <div class="grouped-processes">
                    <h3 style="color: var(--text-primary);">Grouped Processes</h3>
                    <div id="groupedList"></div>
                </div>
                <div class="chart-row">
                    <div class="chart-container">
                        <canvas id="trackMemoryChart"></canvas>
                    </div>
                    <div class="chart-container">
                        <canvas id="trackCpuChart"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        const { ipcRenderer } = require('electron');
        let selectedProcess = null;
        let isUpdatePaused = false;
        let memoryChart = null;
        let cpuChart = null;
        let trackMemoryChart = null;
        let trackCpuChart = null;
        let trackedData = {
            history: new Map(),
            colors: new Map(),
            hidden: new Map(),
            maxHistory: 20
        };
        let memoryHistory = [];
        let processColors = new Map();
        let hiddenDatasets = new Map();

        // Define a color palette with distinct colors
        const DISTINCT_COLORS = [
            '#FF6B6B', // Red
            '#4ECDC4', // Teal
            '#45B7D1', // Light Blue
            '#96CEB4', // Sage
            '#FFEEAD', // Light Yellow
            '#D4A5A5', // Dusty Rose
            '#9B59B6', // Purple
            '#3498DB', // Blue
            '#E67E22', // Orange
            '#2ECC71', // Green
            '#F1C40F', // Yellow
            '#E74C3C', // Bright Red
            '#1ABC9C', // Turquoise
            '#9B59B6', // Violet
            '#34495E'  // Navy
        ];

        let colorIndex = 0;
        function getRandomColor() {
            // Cycle through the colors array
            const color = DISTINCT_COLORS[colorIndex];
            colorIndex = (colorIndex + 1) % DISTINCT_COLORS.length;
            return color;
        }

        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function updateProcessList(processes) {
            const tbody = document.getElementById('processList');
            tbody.innerHTML = '';

            if (!processes || !Array.isArray(processes)) {
                console.error('Invalid processes data received:', processes);
                return;
            }

            if (processes.length === 0) {
                const row = document.createElement('tr');
                row.innerHTML = '<td colspan="5" style="text-align: center;">No processes found</td>';
                tbody.appendChild(row);
                return;
            }

            processes.forEach(process => {
                tbody.appendChild(createProcessRow(process));
            });
        }

        function getColorForProcess(processName) {
            if (!processColors.has(processName)) {
                processColors.set(processName, getRandomColor());
            }
            return processColors.get(processName);
        }

        function normalizeProcessName(name) {
            // Remove numbers and special characters, lowercase
            return name.replace(/[0-9]+/g, '').replace(/[^a-zA-Z]/g, '').toLowerCase();
        }

        function groupProcessData(processData) {
            const grouped = new Map();
            processData.forEach(process => {
                const normalizedName = normalizeProcessName(process.name);
                if (grouped.has(normalizedName)) {
                    const existing = grouped.get(normalizedName);
                    existing.cpu += process.cpu;
                    existing.memory += process.memory;
                    existing.instances.push(process.name);
                } else {
                    grouped.set(normalizedName, {
                        name: process.name,
                        normalizedName: normalizedName,
                        cpu: process.cpu,
                        memory: process.memory,
                        instances: [process.name]
                    });
                }
            });
            return Array.from(grouped.values())
                .sort((a, b) => b.cpu - a.cpu)
                .slice(0, 30); // Limit to top 8 processes for better readability
        }

        function initializeCharts() {
            const chartContainer = document.querySelector('.chart-row');
            chartContainer.style.display = 'flex';
            chartContainer.style.flexDirection = 'column';
            chartContainer.style.gap = '10px';
            chartContainer.style.padding = '20px';
            chartContainer.style.backgroundColor = 'white';
            chartContainer.style.borderRadius = '8px';

            // Create charts row
            const chartsRow = document.createElement('div');
            chartsRow.style.display = 'flex';
            chartsRow.style.flexDirection = 'row';
            chartsRow.style.gap = '20px';
            chartsRow.style.justifyContent = 'center';
            chartsRow.style.height = '200px';

            // Create title and chart containers
            const memorySection = document.createElement('div');
            memorySection.style.flex = '1';
            memorySection.style.maxWidth = '45%';
            memorySection.style.height = '100%';
            memorySection.innerHTML = '<h3 style="text-align: center; margin-bottom: 5px; font-size: 14px;">Memory Usage Over Time</h3>';
            
            const cpuSection = document.createElement('div');
            cpuSection.style.flex = '1';
            cpuSection.style.maxWidth = '45%';
            cpuSection.style.height = '100%';
            cpuSection.innerHTML = '<h3 style="text-align: center; margin-bottom: 5px; font-size: 14px;">CPU Usage Distribution</h3>';

            // Move the canvas elements
            const memoryCanvas = document.getElementById('memoryChart');
            const cpuCanvas = document.getElementById('cpuChart');
            memorySection.appendChild(memoryCanvas);
            cpuSection.appendChild(cpuCanvas);

            // Add charts to the row
            chartsRow.appendChild(memorySection);
            chartsRow.appendChild(cpuSection);

            // Create shared legend container
            const legendContainer = document.createElement('div');
            legendContainer.style.display = 'flex';
            legendContainer.style.justifyContent = 'center';
            legendContainer.style.flexWrap = 'wrap';
            legendContainer.style.gap = '15px';
            legendContainer.style.padding = '10px';
            legendContainer.style.marginTop = '10px';

            // Clear and rebuild chart container
            chartContainer.innerHTML = '';
            chartContainer.appendChild(chartsRow);
            chartContainer.appendChild(legendContainer);

            // Memory Chart
            const memoryCtx = memoryCanvas.getContext('2d');
            memoryChart = new Chart(memoryCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: []
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: {
                        duration: 300
                    },
                    layout: {
                        padding: {
                            left: 10,
                            right: 10,
                            top: 10,
                            bottom: 10
                        }
                    },
                    scales: {
                        x: {
                            grid: {
                                display: false
                            },
                            ticks: {
                                maxTicksLimit: 8,
                                maxRotation: 0,
                                font: {
                                    size: 10
                                }
                            }
                        },
                        y: {
                            beginAtZero: true,
                            title: {
                                display: false
                            },
                            ticks: {
                                callback: function(value) {
                                    return formatBytes(value);
                                },
                                maxTicksLimit: 5,
                                font: {
                                    size: 10
                                }
                            },
                            grid: {
                                color: 'rgba(0,0,0,0.1)'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        }
                    }
                }
            });

            // CPU Chart
            const cpuCtx = cpuCanvas.getContext('2d');
            cpuChart = new Chart(cpuCtx, {
                type: 'pie',
                data: {
                    labels: [],
                    datasets: [{
                        data: [],
                        backgroundColor: []
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: {
                        padding: {
                            left: 10,
                            right: 10,
                            top: 10,
                            bottom: 10
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        }
                    }
                }
            });

            // Style chart containers
            document.querySelectorAll('.chart-container').forEach(container => {
                container.style.height = '160px';
                container.style.position = 'relative';
            });
        }

        function updateCharts(metrics) {
            const groupedData = groupProcessData(metrics.processData);
            
            // Update Memory Chart
            const timestamp = metrics.timestamp;
            memoryHistory.push(timestamp);
            if (memoryHistory.length > trackedData.maxHistory) {
                memoryHistory.shift();
            }

            // Initialize or update datasets
            if (memoryChart.data.datasets.length === 0) {
                // First time setup
                memoryChart.data.datasets = groupedData.map(process => {
                    const color = getColorForProcess(process.normalizedName);
                    return {
                        label: process.name,
                        data: new Array(memoryHistory.length).fill(process.memory),
                        borderColor: color,
                        backgroundColor: color + '40',
                        tension: 0.1,
                        fill: false
                    };
                });
            } else {
                // Update existing datasets
                groupedData.forEach((process, index) => {
                    if (index < memoryChart.data.datasets.length) {
                        const dataset = memoryChart.data.datasets[index];
                        dataset.data.push(process.memory);
                        if (dataset.data.length > trackedData.maxHistory) {
                            dataset.data.shift();
                        }
                        dataset.label = process.name;
                        const color = getColorForProcess(process.normalizedName);
                        dataset.borderColor = color;
                        dataset.backgroundColor = color + '40';
                    }
                });

                // Remove extra datasets if needed
                while (memoryChart.data.datasets.length > groupedData.length) {
                    memoryChart.data.datasets.pop();
                }
            }

            memoryChart.data.labels = memoryHistory;
            memoryChart.update('none'); // Use 'none' mode for smoother updates

            // Update CPU Chart
            cpuChart.data.labels = groupedData.map(p => p.name);
            cpuChart.data.datasets[0].data = groupedData.map(p => p.cpu);
            cpuChart.data.datasets[0].backgroundColor = groupedData.map(p => getColorForProcess(p.normalizedName));
            cpuChart.update('none');

            // Update shared legend
            const legendContainer = document.querySelector('.chart-row > div:last-child');
            legendContainer.innerHTML = '';
            groupedData.forEach((process, index) => {
                const color = getColorForProcess(process.normalizedName);
                const legendItem = document.createElement('div');
                legendItem.style.display = 'flex';
                legendItem.style.alignItems = 'center';
                legendItem.style.gap = '5px';
                legendItem.style.cursor = 'pointer';
                legendItem.style.fontSize = '12px';
                legendItem.style.padding = '2px 5px';
                legendItem.style.borderRadius = '4px';
                legendItem.style.transition = 'all 0.2s ease';
                legendItem.innerHTML = `
                    <span style="width: 12px; height: 12px; background-color: ${color}; display: inline-block; border-radius: 2px;"></span>
                    <span>${process.name}</span>
                `;
                
                // Add hover effect
                legendItem.addEventListener('mouseenter', () => {
                    legendItem.style.backgroundColor = 'var(--bg-tertiary)';
                });
                legendItem.addEventListener('mouseleave', () => {
                    legendItem.style.backgroundColor = '';
                });
                
                // Add click handler for toggling visibility
                legendItem.onclick = () => {
                    const isHidden = memoryChart.getDatasetMeta(index).hidden;
                    memoryChart.getDatasetMeta(index).hidden = !isHidden;
                    cpuChart.getDatasetMeta(0).data[index].hidden = !isHidden;
                    legendItem.style.opacity = isHidden ? '1' : '0.5';
                    memoryChart.update();
                    cpuChart.update();
                };
                legendContainer.appendChild(legendItem);
            });
        }

        function initializeTrackCharts() {
            const memoryCtx = document.getElementById('trackMemoryChart').getContext('2d');
            const cpuCtx = document.getElementById('trackCpuChart').getContext('2d');

            // Basic shared configuration
            const commonConfig = {
                type: 'line',
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    plugins: {
                        legend: {
                            position: 'top',
                            labels: {
                                color: '#3b82f6', // Using blue that's visible in both modes
                                padding: 10,
                                font: { size: 11 }
                            }
                        },
                        title: {
                            display: true,
                            color: '#3b82f6', // Using blue that's visible in both modes
                            font: { size: 14 }
                        }
                    },
                    scales: {
                        x: {
                            grid: {
                                color: 'var(--border-color)'
                            },
                            ticks: {
                                color: '#3b82f6', // Using blue that's visible in both modes
                                maxRotation: 0,
                                maxTicksLimit: 10
                            }
                        },
                        y: {
                            grid: {
                                color: 'var(--border-color)'
                            },
                            ticks: {
                                color: '#3b82f6', // Using blue that's visible in both modes
                                padding: 5
                            }
                        }
                    }
                }
            };

            // Memory Chart
            trackMemoryChart = new Chart(memoryCtx, {
                ...commonConfig,
                data: {
                    labels: [],
                    datasets: []
                },
                options: {
                    ...commonConfig.options,
                    plugins: {
                        ...commonConfig.options.plugins,
                        title: {
                            ...commonConfig.options.plugins.title,
                            text: 'Memory Usage History'
                        }
                    },
                    scales: {
                        ...commonConfig.options.scales,
                        y: {
                            ...commonConfig.options.scales.y,
                            beginAtZero: true,
                            suggestedMin: 0,
                            suggestedMax: 10 * 1024 * 1024, // Start with 10MB max, will auto-adjust
                            ticks: {
                                ...commonConfig.options.scales.y.ticks,
                                callback: formatBytes,
                                stepSize: 1024 * 1024 // 1MB steps
                            }
                        }
                    }
                }
            });

            // CPU Chart
            trackCpuChart = new Chart(cpuCtx, {
                ...commonConfig,
                data: {
                    labels: [],
                    datasets: []
                },
                options: {
                    ...commonConfig.options,
                    plugins: {
                        ...commonConfig.options.plugins,
                        title: {
                            ...commonConfig.options.plugins.title,
                            text: 'CPU Usage History'
                        }
                    },
                    scales: {
                        ...commonConfig.options.scales,
                        y: {
                            ...commonConfig.options.scales.y,
                            beginAtZero: true,
                            suggestedMin: 0,
                            suggestedMax: 100,
                            ticks: {
                                ...commonConfig.options.scales.y.ticks,
                                callback: value => value.toFixed(1) + '%',
                                stepSize: 20 // Show ticks every 20%
                            }
                        }
                    }
                }
            });
        }

        function updateTrackCharts(processes) {
            if (!processes || processes.length === 0) return;

            const timestamp = new Date().toLocaleTimeString();
            const shouldGroup = document.getElementById('groupProcesses').checked;

            // Process the data
            let processesToChart = processes;
            if (shouldGroup) {
                const groupedByName = new Map();
                processes.forEach(process => {
                    const name = process.name;
                    if (!groupedByName.has(name)) {
                        groupedByName.set(name, {
                            name: name,
                            memory: 0,
                            cpu: 0,
                            count: 0
                        });
                    }
                    const group = groupedByName.get(name);
                    group.memory += Math.max(1, process.memory || 1);
                    group.cpu += Math.max(0.01, process.cpu || 0.01);
                    group.count++;
                });

                processesToChart = Array.from(groupedByName.values()).map(group => ({
                    name: group.name,
                    memory: group.memory,
                    cpu: group.cpu / group.count
                }));
            }

            // Update history
            processesToChart.forEach(process => {
                const id = shouldGroup ? process.name : process.pid;
                
                if (!trackedData.colors.has(id)) {
                    trackedData.colors.set(id, getRandomColor());
                }
                
                if (!trackedData.history.has(id)) {
                    trackedData.history.set(id, {
                        timestamps: [],
                        memory: [],
                        cpu: []
                    });
                }

                const history = trackedData.history.get(id);
                history.timestamps.push(timestamp);
                history.memory.push(Math.max(1, process.memory || 1));
                history.cpu.push(Math.max(0.01, process.cpu || 0.01));

                // Keep only last 30 points
                if (history.timestamps.length > 30) {
                    history.timestamps.shift();
                    history.memory.shift();
                    history.cpu.shift();
                }
            });

            // Update Memory Chart
            if (trackMemoryChart) {
                const datasets = Array.from(trackedData.history.entries()).map(([id, data]) => ({
                    label: shouldGroup ? `Group: ${id}` : `PID ${id}`,
                    data: data.memory,
                    borderColor: trackedData.colors.get(id),
                    backgroundColor: trackedData.colors.get(id) + '20',
                    fill: true,
                    tension: 0.4
                }));

                trackMemoryChart.data.labels = Array.from(trackedData.history.values())[0]?.timestamps || [];
                trackMemoryChart.data.datasets = datasets;
                trackMemoryChart.update('none');
            }

            // Update CPU Chart
            if (trackCpuChart) {
                const datasets = Array.from(trackedData.history.entries()).map(([id, data]) => ({
                    label: shouldGroup ? `Group: ${id}` : `PID ${id}`,
                    data: data.cpu,
                    borderColor: trackedData.colors.get(id),
                    backgroundColor: trackedData.colors.get(id) + '20',
                    fill: true,
                    tension: 0.4
                }));

                trackCpuChart.data.labels = Array.from(trackedData.history.values())[0]?.timestamps || [];
                trackCpuChart.data.datasets = datasets;
                trackCpuChart.update('none');
            }
        }

        function updateTrackedProcesses(processes) {
            const trackedList = document.getElementById('trackedList');
            const groupedList = document.getElementById('groupedList');
            trackedList.innerHTML = '';
            groupedList.innerHTML = '';
            
            // Group processes by name
            const groupedProcesses = new Map();
            processes.forEach(process => {
                const name = process.name;
                if (!groupedProcesses.has(name)) {
                    groupedProcesses.set(name, []);
                }
                groupedProcesses.get(name).push(process);
            });
            
            // Update tracked processes list
            processes.forEach(process => {
                const processCard = document.createElement('div');
                processCard.className = 'process-card';
                
                processCard.innerHTML = `
                    <span>PID: ${process.pid}</span>
                    <span>${process.name}</span>
                    <button class="remove-button" onclick="untrackProcess(${process.pid})">Remove</button>
                `;
                
                trackedList.appendChild(processCard);
            });

            // Update grouped processes list
            groupedProcesses.forEach((processes, name) => {
                const groupCard = document.createElement('div');
                groupCard.className = 'group-card';

                const pids = processes.map(p => p.pid).join(', ');
                const totalMemory = processes.reduce((sum, p) => sum + p.memory, 0);
                const avgCpu = processes.reduce((sum, p) => sum + p.cpu, 0) / processes.length;

                groupCard.innerHTML = `
                    <div class="group-card-title">${name}</div>
                    <div class="group-card-content">
                        <div>Process Count: ${processes.length}</div>
                        <div>PIDs: ${pids}</div>
                        <div>Total Memory: ${formatBytes(totalMemory)}</div>
                        <div>Average CPU: ${avgCpu.toFixed(1)}%</div>
                    </div>
                `;

                groupedList.appendChild(groupCard);
            });
        }

        // Store tracked processes data between updates
        let lastTrackedProcesses = [];

        function untrackProcess(pid) {
            ipcRenderer.send('untrack-process', pid);
            trackedData.history.delete(pid);
            if (trackedData.history.size === 0) {
                colorIndex = 0; // Reset when all processes are untracked
            }
        }

        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));                
                tab.classList.add('active');
                document.getElementById(tab.dataset.tab).classList.add('active');
            });
        });

        document.getElementById('pauseUpdate').addEventListener('click', function() {
            isUpdatePaused = !isUpdatePaused;
            this.innerHTML = `
                <span class="icon">${isUpdatePaused ? '‚ñ∂Ô∏è' : '‚è∏Ô∏è'}</span>
                <span>${isUpdatePaused ? 'Resume Update' : 'Pause Update'}</span>
            `;
            
            // Force a chart update when resuming
            if (!isUpdatePaused) {
                const activeTab = document.querySelector('.tab-content.active');
                if (activeTab && activeTab.id === 'track') {
                    updateTrackCharts(lastTrackedProcesses);
                }
            }
        });

        document.getElementById('refresh').addEventListener('click', () => {
            const wasUpdatePaused = isUpdatePaused;
            isUpdatePaused = true; // Temporarily pause updates
            ipcRenderer.send('refresh-processes');
            setTimeout(() => {
                isUpdatePaused = wasUpdatePaused; // Restore previous pause state
            }, 100);
        });

        // Initialize charts when the graphs tab is shown
        document.querySelector('.tab[data-tab="graphs"]').addEventListener('click', () => {
            if (!memoryChart || !cpuChart) {
                initializeCharts();
            }
        });

        document.getElementById('addTrack').addEventListener('click', () => {
            const pid = document.getElementById('trackPid').value;
            if (pid) {
                ipcRenderer.send('track-process', pid);
                document.getElementById('trackPid').value = '';
            }
        });

        document.querySelector('.tab[data-tab="track"]').addEventListener('click', () => {
            if (!trackMemoryChart || !trackCpuChart) {
                initializeTrackCharts();
            }
        });

        ipcRenderer.on('process-update', (event, data) => {
            console.log('Received process-update event with data:', data);
            if (!isUpdatePaused) {
                updateProcessList(data.processes);
                if (document.querySelector('.tab-content#graphs').classList.contains('active')) {
                    updateCharts(data.metrics);
                }
                if (document.querySelector('.tab-content#track').classList.contains('active')) {
                    console.log('Updating tracked processes:', data.trackedProcesses);
                    updateTrackedProcesses(data.trackedProcesses || []);
                    updateTrackCharts(data.trackedProcesses || []);
                }
            }
        });

        document.addEventListener('click', (e) => {
            if (!e.target.closest('.action-menu') && !e.target.closest('.process-row')) {
                document.getElementById('actionMenu').style.display = 'none';
            }
        });

        // Add event listener for grouping toggle
        document.getElementById('groupProcesses').addEventListener('change', function() {
            trackedData.history.clear();
            trackedData.colors.clear();
            trackedData.hidden.clear();
            colorIndex = 0;
        });

        // Add dark mode toggle
        const themeToggle = document.getElementById('themeToggle');
        let isDarkMode = false;

        function toggleTheme() {
            isDarkMode = !isDarkMode;
            document.documentElement.setAttribute('data-theme', isDarkMode ? 'dark' : 'light');
            themeToggle.textContent = isDarkMode ? '‚òÄÔ∏è' : 'üåô';
            
            // Update chart themes if they exist
            if (window.memoryChart) {
                updateChartTheme(window.memoryChart);
            }
            if (window.cpuChart) {
                updateChartTheme(window.cpuChart);
            }
        }

        function updateChartTheme(chart) {
            const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
            const textColor = isDark ? '#f8fafc' : '#0f172a';
            const gridColor = isDark ? '#334155' : '#e2e8f0';
            const backgroundColor = isDark ? '#1e293b' : '#ffffff';
            
            if (chart.options.scales) {
                Object.values(chart.options.scales).forEach(scale => {
                    if (scale.grid) scale.grid.color = gridColor;
                    if (scale.ticks) scale.ticks.color = textColor;
                });
            }

            if (chart.options.plugins && chart.options.plugins.legend) {
                chart.options.plugins.legend.labels.color = textColor;
            }

            chart.canvas.parentElement.style.backgroundColor = backgroundColor;
            chart.update();
        }

        themeToggle.addEventListener('click', toggleTheme);

        // Add intersection observer for animations
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.classList.add('visible');
                }
            });
        }, {
            threshold: 0.1
        });

        // Observe chart containers
        document.querySelectorAll('.chart-container').forEach(el => {
            observer.observe(el);
        });

        // Improve action menu positioning
        function showActionMenu(e, process) {
            const menu = document.getElementById('actionMenu');
            const rect = e.target.closest('tr').getBoundingClientRect();
            
            // Position the menu
            menu.style.left = `${rect.right + 5}px`;
            menu.style.top = `${rect.top}px`;
            
            // Simple display toggle
            menu.classList.add('visible');
            selectedProcess = process;

            // Prevent event bubbling
            e.stopPropagation();
        }

        function createProcessRow(process) {
            const row = document.createElement('tr');
            row.className = 'process-row';
            row.dataset.pid = process.pid;
            
            row.innerHTML = `
                <td>${process.pid}</td>
                <td>${process.name}</td>
                <td>${process.cpu.toFixed(1)}%</td>
                <td>${formatBytes(process.memory)}</td>
                <td>${process.state}</td>
                <td class="actions-cell">
                    <button class="action-button" onclick="showActions(event, ${process.pid})">‚ãÆ</button>
                </td>
            `;

            return row;
        }

        // Handle showing/hiding the dropdown
        function showActions(event, pid) {
            event.stopPropagation();
            
            // Remove any existing dropdowns
            document.querySelectorAll('.dropdown-menu').forEach(menu => {
                document.body.removeChild(menu);
            });
            
            // Create new dropdown
            const dropdown = document.createElement('div');
            dropdown.className = 'dropdown-menu';
            dropdown.innerHTML = `
                <div class="dropdown-item" onclick="handleAction('kill', ${pid})">
                    ‚ö° Kill Process
                </div>
                <div class="dropdown-item" onclick="handleAction('pause', ${pid})">
                    ‚è∏Ô∏è Pause Process
                </div>
                <div class="dropdown-item" onclick="handleAction('resume', ${pid})">
                    ‚ñ∂Ô∏è Resume Process
                </div>
                <div class="dropdown-item" onclick="handleAction('priority', ${pid})">
                    ‚öôÔ∏è Change Priority
                </div>
            `;

            // Position the dropdown
            const button = event.currentTarget;
            const rect = button.getBoundingClientRect();
            
            // Append to body
            document.body.appendChild(dropdown);
            
            // Position after append to get correct measurements
            dropdown.style.display = 'block';
            dropdown.style.left = `${rect.right + 5}px`;
            dropdown.style.top = `${rect.top}px`;

            // Adjust position if off screen
            const dropdownRect = dropdown.getBoundingClientRect();
            if (dropdownRect.right > window.innerWidth) {
                dropdown.style.left = `${rect.left - dropdownRect.width - 5}px`;
            }
            if (dropdownRect.bottom > window.innerHeight) {
                dropdown.style.top = `${rect.bottom - dropdownRect.height}px`;
            }
        }

        // Handle action clicks
        function handleAction(action, pid) {
            console.log('Action:', action, 'PID:', pid);
            ipcRenderer.send('process-action', {
                action,
                pid: pid
            });
            
            // Hide the dropdown after action
            document.getElementById(`dropdown-${pid}`).style.display = 'none';
        }

        // Close dropdowns when clicking outside
        document.addEventListener('click', (event) => {
            if (!event.target.closest('.dropdown-menu') && !event.target.closest('.action-button')) {
                document.querySelectorAll('.dropdown-menu').forEach(menu => {
                    document.body.removeChild(menu);
                });
            }
        });

        // Add feedback for process actions
        ipcRenderer.on('process-action-result', (event, { success, error, action, pid }) => {
            if (success) {
                console.log(`Successfully performed ${action} on process ${pid}`);
            } else {
                console.error(`Failed to perform ${action} on process ${pid}:`, error);
                // You could show this in the UI if desired
            }
        });

        // Add cleanup on tab switch
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.dropdown-menu').forEach(menu => {
                    if (document.body.contains(menu)) {
                        document.body.removeChild(menu);
                    }
                });
            });
        });

        // Add back the theme toggle functionality for the main graphs
        function updateChartsTheme() {
            const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
            const textColor = isDark ? '#f8fafc' : '#0f172a';
            const gridColor = isDark ? '#334155' : '#e2e8f0';
            
            const commonOptions = {
                scales: {
                    x: {
                        ticks: { color: textColor },
                        grid: { color: gridColor }
                    },
                    y: {
                        ticks: { color: textColor },
                        grid: { color: gridColor }
                    }
                },
                plugins: {
                    legend: {
                        labels: { color: textColor }
                    },
                    title: {
                        color: textColor
                    }
                }
            };

            // Update only the main charts (not track charts)
            [memoryChart, cpuChart].forEach(chart => {
                if (chart) {
                    if (chart.options.scales.x) {
                        Object.assign(chart.options.scales.x.ticks, commonOptions.scales.x.ticks);
                        Object.assign(chart.options.scales.x.grid, commonOptions.scales.x.grid);
                    }
                    if (chart.options.scales.y) {
                        Object.assign(chart.options.scales.y.ticks, commonOptions.scales.y.ticks);
                        Object.assign(chart.options.scales.y.grid, commonOptions.scales.y.grid);
                    }
                    if (chart.options.plugins.legend) {
                        Object.assign(chart.options.plugins.legend.labels, commonOptions.plugins.legend.labels);
                    }
                    if (chart.options.plugins.title) {
                        Object.assign(chart.options.plugins.title, commonOptions.plugins.title);
                    }
                    chart.update();
                }
            });
        }

        // Add theme toggle listener for main graphs
        document.getElementById('themeToggle').addEventListener('click', () => {
            updateChartsTheme();
        });

        // Call on initial load for main graphs
        window.addEventListener('load', () => {
            updateChartsTheme();
        });

        // Add legend click handler to store hidden state
        function addLegendClickHandler(chart) {
            chart.options.plugins.legend.onClick = function(e, legendItem, legend) {
                const index = legendItem.datasetIndex;
                const ci = legend.chart;
                const id = ci.data.datasets[index].label.split(' ').pop(); // Extract PID or group name
                
                // Toggle hidden state in our persistent storage
                trackedData.hidden.set(id, !trackedData.hidden.get(id));
                
                // Update chart visibility
                if (ci.isDatasetVisible(index)) {
                    ci.hide(index);
                } else {
                    ci.show(index);
                }
            };
        }
    </script>
</body>
</html>